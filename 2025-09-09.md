# 9 September 2025
# or, …

_09:00–14:00 (5h + 4h30m = 9h30m)_  

---

## Per-pathogen runtimes

Response to <https://github.com/nextstrain/cli/issues/448> and [Victor's
thinking](https://docs.google.com/document/d/1KrElHFEk8c-2zHDs91OqZU0AKme_7WBJ6REUbEzk6aU/edit?tab=t.0).

_I have absolutely oodles of prior thinking here, which I haven't gone to the
trouble of linking here.  But here's the latest gist._

> [!IMPORTANT]  
> **7 Nov clarification**
>
> Note that the below makes an unsaid assumption that per-pathogen runtimes are
> distributed _separately_ from pathogen sources, similar to how our current
> single base runtime is separate from pathogen sources.  I think this is a
> reasonable place to _start_ as it lets work focus on how to specify and
> bundle pathogen-specific dependencies and how we distribute those
> per-pathogen runtimes without also changing how pathogen source is
> distributed (e.g. to `nextstrain setup`) and used (e.g. by `nextstrain run`).
> A separate runtime and source fits into the current execution model we have.
> 
> That said, I think the _aim_ should still be to eventually bundle pathogen
> source into its runtime image/package.  That is the original vision for
> "workflows as programs" (or the "second half" of it at least).  Combining
> source + runtime may necessitate changes to the `nextstrain-pathogen.yaml`
> registration data sketched out below, and will definitely require broader
> changes to how Nextstrain CLI runs pathogen workflows.
>
> Finally, even with pathogen sources and runtimes bundled together into one
> distributable image/package, there will still be use cases and a need to
> specify them separately, e.g. use a local copy of the pathogen source instead
> of the copy in the pathogen image/package.  Put another way, these features
> are conceptually _additive_ and _optional to use_.

  - Runtime as Docker image _and_ Conda meta-package (or similar, e.g. Pixi
    manifest, if we move away from meta-packages and their issues).

    Both are important for supporting a broad set of users who have different
    underlying runtime platforms available to them or different
    reproducibility/portability needs.

  - Runtime image/package _name_ (without version) referenced in
    `nextstrain-pathogen.yaml` for flexibility and explicitness, but a clear
    and strong convention on what this name should be almost all the time,
    e.g.:

        ghcr.io/nextstrain/{pathogen}
        nextstrain::nextstrain-{pathogen}

        ghcr.io/nextstrain/seasonal-flu
        nextstrain::nextstrain-seasonal-flu

  - Runtime image/package version requirement spec referenced in
    `nextstrain-pathogen.yaml`, e.g.:

        runtime:
          oci-image:
            name: ghcr.io/nextstrain/seasonal-flu
            version: >=X, <Y
          conda-package:
            channel: nextstrain
            name: nextstrain-seasonal-flu
            version: >=Z

    A spec allows us to restrict minimum version as necessary without needing
    to update `nextstrain-pathogen.yaml` every time we update the pathogen
    runtimes to include updates to the base runtimes.  Similarly, allows
    restricting maximum version or known bad versions if a pathogen is not yet
    ready for a change or there's a bad change.

    This _could_ be combined with the runtime name, but I suspect keeping them
    separate in the YAML (i.e. rather than in a single string) is better.

  - Nextstrain CLI would fall back to a base runtime in the absence of a
    pathogen-specific one referenced in `nextstrain-pathogen.yaml`.

  - Docker images could be defined with `Dockerfile`s (i.e. `FROM
    nextstrain/base:…`), but I think the experience for workflow authors would
    be much much better if we used [Buildpacks](https://buildpacks.io) (i.e.
    with the `pack` program).  In particular, using Buildpacks means not
    dealing with Dockerfiles at all, but with standard language ecosystem
    packaging formats (e.g. `requirements.txt`, `environment.yaml`,
    `packages.json`, etc).

    Conda packages could be defined with a `conda-build` recipe (i.e.
    `meta.yaml` with `requirements: run: nextstrain-base ==…`), but the
    experience for workflow authors might be quite a bit better if we used
    [Pixi](https://pixi.sh/latest/) (after switching the Conda runtime platform
    to it as well).

    The mechanics here could (and probably should) be boxed up into a
    Nextstrain CLI command or two for convenience and ease.

  - We should consider how the base runtimes are shared (or not) between
    pathogen runtimes so as not to use inordinate amounts of disk space and
    network transfer.

    For Docker, this should Just Work thanks to image layers.

    For Conda, the package cache should help as environments link into it, but
    the usage of the package cache depends on the install method and OS (i.e.
    sometimes copies instead of links are used).  For Pixi, there is hopefully
    something akin to the package cache.

  - Updates to the base runtime would be _pulled into_ the pathogen runtime by
    rebuilding the latter periodically (e.g. with a scheduled GitHub Actions
    workflow).  This easily allows for third-party pathogen runtimes to get
    updates as well.  Additionally, we could _push_ base updates to our
    pathogens by triggering a rebuild to avoid undue lag.
