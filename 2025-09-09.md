# 9 September 2025
# or, …

_09:00–14:00 (5h + 4h30m = 9h30m)_  

---

## Per-pathogen runtimes

Response to <https://github.com/nextstrain/cli/issues/448> and [Victor's
thinking](https://docs.google.com/document/d/1KrElHFEk8c-2zHDs91OqZU0AKme_7WBJ6REUbEzk6aU/edit?tab=t.0).

_I have absolutely oodles of prior thinking here, which I haven't gone to the
trouble of linking here.  But here's the latest gist._

  - Runtime as Docker image _and_ Conda meta-package (or similar, e.g. Pixi
    manifest, if we move away from meta-packages and their issues).

    Both are important for supporting a broad set of users who have different
    underlying runtime platforms available to them or different
    reproducibility/portability needs.

  - Runtime image/package _name_ (without version) referenced in
    `nextstrain-pathogen.yaml` for flexibility and explicitness, but a clear
    and strong convention on what this name should be almost all the time,
    e.g.:

        ghcr.io/nextstrain/{pathogen}
        nextstrain::nextstrain-{pathogen}

        ghcr.io/nextstrain/seasonal-flu
        nextstrain::nextstrain-seasonal-flu

  - Runtime image/package version requirement spec referenced in
    `nextstrain-pathogen.yaml`, e.g.:

        runtime:
          oci-image:
            name: ghcr.io/nextstrain/seasonal-flu
            version: >=X, <Y
          conda-package:
            channel: nextstrain
            name: nextstrain-seasonal-flu
            version: >=Z

    A spec allows us to restrict minimum version as necessary without needing
    to update `nextstrain-pathogen.yaml` every time we update the pathogen
    runtimes to include updates to the base runtimes.  Similarly, allows
    restricting maximum version or known bad versions if a pathogen is not yet
    ready for a change or there's a bad change.

    This _could_ be combined with the runtime name, but I suspect keeping them
    separate in the YAML (i.e. rather than in a single string) is better.

  - Nextstrain CLI would fall back to a base runtime in the absence of a
    pathogen-specific one referenced in `nextstrain-pathogen.yaml`.

  - Docker images could be defined with `Dockerfile`s (i.e. `FROM
    nextstrain/base:…`), but I think the experience for workflow authors would
    be much much better if we used [Buildpacks](https://buildpacks.io) (i.e.
    with the `pack` program).  In particular, using Buildpacks means not
    dealing with Dockerfiles at all, but with standard language ecosystem
    packaging formats (e.g. `requirements.txt`, `environment.yaml`,
    `packages.json`, etc).

    Conda packages could be defined with a `conda-build` recipe (i.e.
    `meta.yaml` with `requirements: run: nextstrain-base ==…`), but the
    experience for workflow authors might be quite a bit better if we used
    [Pixi](https://pixi.sh/latest/) (after switching the Conda runtime platform
    to it as well).

    The mechanics here could (and probably should) be boxed up into a
    Nextstrain CLI command or two for convenience and ease.

  - We should consider how the base runtimes are shared (or not) between
    pathogen runtimes so as not to use inordinate amounts of disk space and
    network transfer.

    For Docker, this should Just Work thanks to image layers.

    For Conda, the package cache should help as environments link into it, but
    the usage of the package cache depends on the install method and OS (i.e.
    sometimes copies instead of links are used).  For Pixi, there is hopefully
    something akin to the package cache.

  - Updates to the base runtime would be _pulled into_ the pathogen runtime by
    rebuilding the latter periodically (e.g. with a scheduled GitHub Actions
    workflow).  This easily allows for third-party pathogen runtimes to get
    updates as well.  Additionally, we could _push_ base updates to our
    pathogens by triggering a rebuild to avoid undue lag.
