# 28 October 2025
# or, the last day before my last lab meeting

_09:00‚Äì14:30 (5h30m + 4h = 9h30m)_  
_22:30‚Äì01:30 (3h + 9h30m = 12h30m)_

---

This became "[How to computer](https://docs.google.com/presentation/d/1LJcWlynJTmsZVO8TCYgpjjkETkdbAFzvY6xcgrNVoNo)".

---

wtf to present about, the eternal question.

I posed this to Trevor (and was thinking about punting).  He suggested:

> Wisdom on what makes for good code? What does it look like? What processes
> result in it? It wouldn't have to be 30 minutes, but something like this
> would feel like a natural departure present if you're up for it.

This got me thinking, but I really don't want to be preachy.  So maybe
something like "ways of thinking about the computer", which includes some
thoughts on "good code" (üò¨).


## ‚ÄúWays of thinking‚Äù

- Writing code is writing; draft, revise, repeat
    - examples are the thing that would motivate this, but ugh finding them
    - draft (prototype) freely
    - do not be precious with first drafts (prototypes)
    - do not mistake first drafts (prototypes) for the final thing

    - it is easy to write more more more; it is hard to boil writing down to
      its essence, its core; but editing is what makes great things great
      (films, songs, photos, books)

    - use names to communicate intent
    - sketch out different approaches to get a better sense of their forms, how
      they'd work, etc.
    - step back and consider if changing something else will make your current
      change easier, more coherent, etc.
        - (show diagram)
    - if the data structures are awkward, the data model is probably wrong/incomplete
    - aim for
        - coherency
        - no accidental (unnecessary) complexity
            - but embrace essential complexity
        - flexibility thru ease of _change_ over time, not necessarily
          _ultimate configurability_
    - two audiences: other people; the computer
      you are primarily communicating with another human

- Read well to write well.

- Dependencies to simply your code, not your understanding
    - May be useful to _delay_ your need to understand
    - read your dependencies

- Look ‚Äúunder the hood‚Äù (but better metaphor)
    - Ok: The repo on GitHub
    - Better: The package on PyPI/NPM/etc.
    - Best: The files on your computer

- Take on the means of your production if necessary
    - adopt your dependencies
    - Open source is about having access to the source, about being able to
      adapt your tools as needed to your situation

    - (It's also free labor and not building the same things ad infinitum, but
      not _just_ that)

- Software (nay, the computer) can be understood, completely
    - Nothing in this realm is magic
    - Old not-quite-coworker's post <https://blog.nelhage.com/post/computers-can-be-understood/>
