# 14 July 2022
# or, a debugging breakthrough, finally?

_following up on past two days of digging from [2022-07-12](2022-07-12.txt)_

With fresh eyes this morning and eyeballing the `DEBUG="*"` logs from the
canary some more, I was able to consistently reproduce the problem!

For a request to fail with the 503 (H18), it must:

  - go thru the handlers in src/endpoints/sources.js, e.g. via the RESTful API
    or the Charon API since 62d17e1.

  - have a valid session cookie; requests without a session are unaffected (!)

  - be conditioned by valid If-Modified-Since and/or If-None-Match headers such
    that a 304 is expected.

On the server side, it's also possible the local fetch() cache needs to be
populated first (e.g. requests only exhibit the error on cache revalidation
instead of a cache miss), but I haven't confirmed that yet.

Not sure what the ultimate cause is, but the proximate cause appears to be that
on the Express routing/handler stack, `next()` is being called after the
response should already be finished (e.g. the request has already hit a
terminal handler).  This abnormally continues the request processing onto
further routes, to the point of passing thru

    app.use(endpoints.static.gatsbyAssets);
    
and then our final

    app.use((req, res, next) => next(new NotFound()))
    
and ending up in our error handler.

What is calling `next()` is not yet clear, but `@awaitjs/express`'s handling of
`next()` is suspect; see [previous notes](2022-07-12.txt) as well as [bug
1](https://github.com/vkarpov15/awaitjs-express/pull/23/files) and [bug
2](https://github.com/vkarpov15/awaitjs-express/pull/27/files).  We're running
0.6.3 and while bug 1 was introduced in 0.7.1 (then fixed (maybe) in 0.7.2),
bug 2 was fixed in 0.8.0 but was present long before 0.6.3.  When reading the
code, I also noted that it can swallow errors if the headers have already been
sent:

    } catch(err) {
      // trs: should unconditionally call next(err) to pass it up the chain
      res.headersSent ? null : next(err);
    }

Given all the above, even if `@awaitjs/express` isn't actually at fault here,
I'd like to replace it with our own simpler, more correct wrapper instead.  I
think a simpler wrapper should be straightforward; all the
complexity/difficulties in `@awaitjs/express`'s impl. are because they're
trying to change the model of request flow in Express to not require async
middleware functions to call `next()`, but that's not something we need/want.
It wasn't clear when adopting this module to make async handlers work well that
it also changed the request flow model.

Anyway, there's more to debug here to understand why this is happening, but it
should be much easier with a reliable repro.
