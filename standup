#!/bin/bash
set -euo pipefail
shopt -s nocasematch
shopt -s nullglob

path="$(dirname $(realpath $0))"
repo="$path"
cmd=edit
date=today
file=

main() {
    for arg; do
        case "$arg" in
            git)
                shift
                exec git -C $repo "$@";;

            status|st|diff|di|pull|grep)
                exec git -C $repo "$@";;

            commit|ci)
                shift
                msg="$*"
                git -C $repo add .
                exec git -C $repo commit -m "${msg:-more thoughts}";;

            push)
                shift
                msg="$*"
                git -C $repo add .
                if [[ -n "$(git -C $repo status --porcelain)" ]]; then
                    git -C $repo commit -m "${msg:-more thoughts}"
                fi
                exec git -C $repo push;;

            review)
                exec $EDITOR -c 'last' $(list-files | tac);;

            view)
                cmd=pan
                shift;;

            preview)
                cmd=markdown2html
                shift;;

            link|open)
                cmd="xdg-open"
                repo="$(git -C $repo remote get-url origin)"

                if [[ ! $repo =~ github\.com ]]; then
                    echo "Remote origin ($repo) doesn't appear to be GitHub." >&2
                    exit 1
                fi

                # Rewrite repo to URL
                repo="${repo#*github.com[:/]}"
                repo="${repo%.git}"
                repo="https://github.com/$repo/blob/master"   # assume we're always on master for now
                shift;;

            edit)
                # no-op, we default to this
                shift;;

            *)
                date="$*"
                break;;
        esac
    done

    if [[ $date =~ ^(last|latest|prev(ious)?)?$ ]]; then
        # Find the last/previous entry.
        file="$(list-files | head -n1)"

    elif [[ $date =~ ^-[1-9][0-9]*$ ]]; then
        # Find the Nth-latest entry.
        n=$((date * -1))
        file="$(list-files | head -n "$n" | tail -n 1)"

    elif [[ $date =~ ^(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$ ]]; then
        # Prefer past days when referring to by name.  I rarely write about the
        # future and more frequently want to re-read the past.
        date="last $date"
    fi

    if [[ -z $file ]]; then
        date="$(date +%F -d "$date")"
        file="$(list-files "$date" | head -n1)"

        if [[ -z $file ]]; then
            file="$repo/$date.md"
        fi
    fi

    if [[ $cmd == edit ]]; then
        # Don't use /usr/bin/edit because it might try to be smart and use
        # mailcap depending on the extension or magic bytes.
        cmd="$EDITOR"

        if [[ ! -s "$file" ]]; then
            cat >"$file" <<.
# $(date -d "$date" +"%-d %B %Y")
# or, â€¦
.
        fi
    fi

    exec $cmd "$file"
}

list-files() {
    local basename="${1:-????-??-??}"
    printf '%s\n' "$repo"/$basename.* | sort -r
}

main "$@"
