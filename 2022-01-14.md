# 14 January 2022
# or, rST formatter for command help

vendor/fork sphinx.writers.text

use vanilla docutils from there
  no extra deps
  pure python

Runtime config:

```
settings_overrides = {
  "report_level": 5,
  "halt_level": 5,
  "exit_status_level": 5,
  "secnum_xform": False,
  "strip_comments": True,
}
```

CI config to find issues when iterating over `--help`:

```
settings_overrides = {
  "report_level": 2,        # report warnings and higher
  "halt_level": 5,`         # don't halt so we report all issues
  "exit_status_level": 2,   # exit with error (?) at end if any warning reported during run
  "secnum_xform": False,
  "strip_comments": True,
}
```


```
$ python3
Python 3.6.9 (default, Dec  8 2021, 21:08:43)
[GCC 8.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import docutils
>>> import nextstrain.cli.command.remote
>>> remote.__doc__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'remote' is not defined
>>> nextstrain.cli.command.remote.__doc__
"\nUpload, download, and manage remote datasets and narratives.\n\nnextstrain.org is the primary remote source/destination, but Amazon S3 buckets\nare also supported and necessary for some use cases. [#history]_\n\nnextstrain.org\n    Remote paths are the same URLs used to view a dataset or narrative on the\n    web, e.g. ``https://nextstrain.org/ncov/open/global``.\n\n    As a convenience, the scheme (``https://``) may be omitted, e.g.\n    ``nextstrain.org/ncov/open/global``.\n\n    As a further convenience for Nextstrain Groups URLs, the domain\n    (``nextstrain.org``) may also be omitted, e.g.\n    ``groups/blab/sars-like-cov`` works as well as\n    ``https://nextstrain.org/groups/blab/sars-like-cov``.\n\n    Read-only actions may be performed against public paths without\n    authentication.  To manage a private Nextstrain Group or upload/delete a\n    public path, first login with nextstrain.org credentials using\n    :doc:`/commands/login`.\n\nAmazon S3\n    Remote paths start with ``s3://`` and specify the bucket name and\n    individual file path/prefix, e.g. ``s3://my-bucket/some/prefix``.\n\n    All actions require AWS credentials.  The following environment variables\n    can be used to provide credentials:\n\n        * ``AWS_ACCESS_KEY_ID``\n        * ``AWS_SECRET_ACCESS_KEY``\n\n    Amazon's documentation includes more information on these `env vars`_ as\n    well as using a persistent `credentials file`_\n    (:file:`~/.aws/credentials`).\n\n    .. _env vars: https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#environment-variables\n    .. _credentials file: https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#shared-credentials-file\n\nFor more information on dataset (Auspice JSON) and narrative (Markdown) files,\nsee :doc:`docs.nextstrain.org:reference/data-formats`.\n\n.. [#history] In previous versions, only Amazon S3 buckets were supported.  The\n    introduction of nextstrain.org support largely obsoletes the need to use S3\n    directly.  Exceptions include if you need to manage v1 datasets (i.e.  separate\n    ``*_tree.json`` and ``*_meta.json`` files) or Nextstrain Group overview/logo\n    files (``group-overview.md`` or ``group-logo.png``).\n"
>>> docutils.core
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'docutils' has no attribute 'core'
>>> import docutils.core
>>> docutils.core.publi
docutils.core.publish_cmdline(            docutils.core.publish_doctree(            docutils.core.publish_from_doctree(       docutils.core.publish_programmatically(
docutils.core.publish_cmdline_to_binary(  docutils.core.publish_file(               docutils.core.publish_parts(              docutils.core.publish_string(
>>> docutils.core.publish_string
<function publish_string at 0x7fe4016a21e0>
>>> help(docutils.core.publish_string)
Help on function publish_string in module docutils.core:

publish_string(source, source_path=None, destination_path=None, reader=None, reader_name='standalone', parser=None, parser_name='restructuredtext', writer=None, writer_name='pseudoxml', setti
    Set up & run a `Publisher` for programmatic use with string I/O.  Return
    the encoded string or Unicode string output.

    For encoded string output, be sure to set the 'output_encoding' setting to
    the desired encoding.  Set it to 'unicode' for unencoded Unicode string
    output.  Here's one way::

        publish_string(..., settings_overrides={'output_encoding': 'unicode'})

    Similarly for Unicode string input (`source`)::

        publish_string(..., settings_overrides={'input_encoding': 'unicode'})

    Parameters: see `publish_programmatically`.

>>> docutils.core.publish_string(nextstrain.cli.command.remote.__doc__)
<string>:19: (ERROR/3) Unknown interpreted text role "doc".
<string>:34: (ERROR/3) Unknown interpreted text role "file".
<string>:41: (ERROR/3) Unknown interpreted text role "doc".
b'<document source="<string>">\n    <paragraph>\n        Upload, download, and manage remote datasets and narratives.\n    <paragraph>\n        nextstrain.org is the primary remote source/destination, but Amazon S3 buckets\n        are also supported and necessary for some use cases. \n        <footnote_reference auto="1" ids="id1" refid="history">\n            1\n    <definition_list>\n        <definition_list_item>\n            <term>\n                nextstrain.org\n            <definition>\n                <paragraph>\n                    Remote paths are the same URLs used to view a dataset or narrative on the\n                    web, e.g. \n                    <literal>\n                        https://nextstrain.org/ncov/open/global\n                    .\n                <paragraph>\n                    As a convenience, the scheme (\n                    <literal>\n                        https://\n                    ) may be omitted, e.g.\n                    <literal>\n                        nextstrain.org/ncov/open/global\n                    .\n                <paragraph>\n                    As a further convenience for Nextstrain Groups URLs, the domain\n                    (\n                    <literal>\n                        nextstrain.org\n                    ) may also be omitted, e.g.\n                    <literal>\n                        groups/blab/sars-like-cov\n                     works as well as\n                    <literal>\n                        https://nextstrain.org/groups/blab/sars-like-cov\n                    .\n                <paragraph>\n                    Read-only actions may be performed against public paths without\n                    authentication.  To manage a private Nextstrain Group or upload/delete a\n                    public path, first login with nextstrain.org credentials using\n                    <problematic ids="id3" refid="id2">\n                        :doc:`/commands/login`\n                    .\n                <system_message backrefs="id3" ids="id2" level="3" line="19" source="<string>" type="ERROR">\n                    <paragraph>\n                        Unknown interpreted text role "doc".\n        <definition_list_item>\n            <term>\n                Amazon S3\n            <definition>\n                <paragraph>\n                    Remote paths start with \n                    <literal>\n                        s3://\n                     and specify the bucket name and\n                    individual file path/prefix, e.g. \n                    <literal>\n                        s3://my-bucket/some/prefix\n                    .\n                <paragraph>\n                    All actions require AWS credentials.  The following environment variables\n                    can be used to provide credentials:\n                <block_quote>\n                    <bullet_list bullet="*">\n                        <list_item>\n                            <paragraph>\n                                <literal>\n                                    AWS_ACCESS_KEY_ID\n                        <list_item>\n                            <paragraph>\n                                <literal>\n                                    AWS_SECRET_ACCESS_KEY\n                <paragraph>\n                    Amazon\'s documentation includes more information on these \n                    <reference name="env vars" refuri="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#environment-variables">\n                        env vars\n                     as\n                    well as using a persistent \n                    <reference name="credentials file" refuri="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#shared-credentials-file">\n                        credentials file\n                    \n                    (\n                    <problematic ids="id5" refid="id4">\n                        :file:`~/.aws/credentials`\n                    ).\n                <system_message backrefs="id5" ids="id4" level="3" line="34" source="<string>" type="ERROR">\n                    <paragraph>\n                        Unknown interpreted text role "file".\n                <target ids="env-vars" names="env\\ vars" refuri="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#environment-variables">\n                <target ids="credentials-file" names="credentials\\ file" refuri="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html#shared-credentials-file">\n    <paragraph>\n        For more information on dataset (Auspice JSON) and narrative (Markdown) files,\n        see \n        <problematic ids="id7" refid="id6">\n            :doc:`docs.nextstrain.org:reference/data-formats`\n        .\n    <system_message backrefs="id7" ids="id6" level="3" line="41" source="<string>" type="ERROR">\n        <paragraph>\n            Unknown interpreted text role "doc".\n    <footnote auto="1" backrefs="id1" ids="history" names="history">\n        <label>\n            1\n        <paragraph>\n            In previous versions, only Amazon S3 buckets were supported.  The\n            introduction of nextstrain.org support largely obsoletes the need to use S3\n            directly.  Exceptions include if you need to manage v1 datasets (i.e.  separate\n            <literal>\n                *_tree.json\n             and \n            <literal>\n                *_meta.json\n             files) or Nextstrain Group overview/logo\n            files (\n            <literal>\n                group-overview.md\n             or \n            <literal>\n                group-logo.png\n            ).\n'
>>> docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer_name='manpage')
<string>:19: (ERROR/3) Unknown interpreted text role "doc".
<string>:34: (ERROR/3) Unknown interpreted text role "file".
<string>:41: (ERROR/3) Unknown interpreted text role "doc".
b'.\\" Man page generated from reStructuredText.\n.\n.TH   "" "" ""\n.SH NAME\n \\- \n.\n.nr rst2man-indent-level 0\n.\n.de1 rstReportMargin\n\\\\$1 \\\\n[an-margin]\nlevel \\\\n[rst2man-indent-level]\nlevel margin: \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]\n-\n\\\\n[rst2man-indent0]\n\\\\n[rst2man-indent1]\n\\\\n[rst2man-indent2]\n..\n.de1 INDENT\n.\\" .rstReportMargin pre:\n. RS \\\\$1\n. nr rst2man-indent\\\\n[rst2man-indent-level] \\\\n[an-margin]\n. nr rst2man-indent-level +1\n.\\" .rstReportMargin post:\n..\n.de UNINDENT\n. RE\n.\\" indent \\\\n[an-margin]\n.\\" old: \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]\n.nr rst2man-indent-level -1\n.\\" new: \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]\n.in \\\\n[rst2man-indent\\\\n[rst2man-indent-level]]u\n..\nUpload, download, and manage remote datasets and narratives.\n.sp\nnextstrain.org is the primary remote source/destination, but Amazon S3 buckets\nare also supported and necessary for some use cases. [1]\n.INDENT 0.0\n.TP\n.B nextstrain.org\nRemote paths are the same URLs used to view a dataset or narrative on the\nweb, e.g. \\fBhttps://nextstrain.org/ncov/open/global\\fP\\&.\n.sp\nAs a convenience, the scheme (\\fBhttps://\\fP) may be omitted, e.g.\n\\fBnextstrain.org/ncov/open/global\\fP\\&.\n.sp\nAs a further convenience for Nextstrain Groups URLs, the domain\n(\\fBnextstrain.org\\fP) may also be omitted, e.g.\n\\fBgroups/blab/sars\\-like\\-cov\\fP works as well as\n\\fBhttps://nextstrain.org/groups/blab/sars\\-like\\-cov\\fP\\&.\n.sp\nRead\\-only actions may be performed against public paths without\nauthentication.  To manage a private Nextstrain Group or upload/delete a\npublic path, first login with nextstrain.org credentials using\n\n.nf\n:doc:\\(ga/commands/login\\(ga\n.fi\n\\&.\n.IP "System Message: ERROR/3 (<string>:, line 19)"\nUnknown interpreted text role "doc".\n.TP\n.B Amazon S3\nRemote paths start with \\fBs3://\\fP and specify the bucket name and\nindividual file path/prefix, e.g. \\fBs3://my\\-bucket/some/prefix\\fP\\&.\n.sp\nAll actions require AWS credentials.  The following environment variables\ncan be used to provide credentials:\n.INDENT 7.0\n.INDENT 3.5\n.INDENT 0.0\n.IP \\(bu 2\n\\fBAWS_ACCESS_KEY_ID\\fP\n.IP \\(bu 2\n\\fBAWS_SECRET_ACCESS_KEY\\fP\n.UNINDENT\n.UNINDENT\n.UNINDENT\n.sp\nAmazon\\(aqs documentation includes more information on these \\fI\\%env vars\\fP as\nwell as using a persistent \\fI\\%credentials file\\fP\n(\n.nf\n:file:\\(ga~/.aws/credentials\\(ga\n.fi\n).\n.IP "System Message: ERROR/3 (<string>:, line 34)"\nUnknown interpreted text role "file".\n.UNINDENT\n.sp\nFor more information on dataset (Auspice JSON) and narrative (Markdown) files,\nsee \n.nf\n:doc:\\(gadocs.nextstrain.org:reference/data\\-formats\\(ga\n.fi\n\\&.\n.IP "System Message: ERROR/3 (<string>:, line 41)"\nUnknown interpreted text role "doc".\n.IP [1] 5\nIn previous versions, only Amazon S3 buckets were supported.  The\nintroduction of nextstrain.org support largely obsoletes the need to use S3\ndirectly.  Exceptions include if you need to manage v1 datasets (i.e.  separate\n\\fB*_tree.json\\fP and \\fB*_meta.json\\fP files) or Nextstrain Group overview/logo\nfiles (\\fBgroup\\-overview.md\\fP or \\fBgroup\\-logo.png\\fP).\n.\\" Generated by docutils manpage writer.\n.\n'
>>> from pathlib import Path
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer_name='manpage')
<string>:19: (ERROR/3) Unknown interpreted text role "doc".
<string>:34: (ERROR/3) Unknown interpreted text role "file".
<string>:41: (ERROR/3) Unknown interpreted text role "doc".
>>> Path("/tmp/man").write_bytes(m)
3104
>>> import sphinx.writers.text
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=sphinx.writers.text)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 416, in publish_string
    enable_exit_status=enable_exit_status)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 661, in publish_programmatically
    settings_spec, settings_overrides, config_section)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 141, in process_programmatic_settings
    **defaults)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 128, in get_settings
    usage, description, settings_spec, config_section, **defaults)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 115, in setup_option_parser
    usage=usage, description=description)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/frontend.py", line 598, in __init__
    self.populate_from_components(self.components)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/frontend.py", line 617, in populate_from_components
    settings_spec = component.settings_spec
AttributeError: module 'sphinx.writers.text' has no attribute 'settings_spec'
>>> sphinx.writers.text
<module 'sphinx.writers.text' from '/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/sphinx/writers/text.py'>
>>> sphinx.writers.text.
sphinx.writers.text.Any(               sphinx.writers.text.Optional(          sphinx.writers.text.TextWriter(        sphinx.writers.text.math
sphinx.writers.text.Cell(              sphinx.writers.text.STDINDENT          sphinx.writers.text.Tuple(             sphinx.writers.text.my_wrap(
sphinx.writers.text.Dict(              sphinx.writers.text.Set(               sphinx.writers.text.Union(             sphinx.writers.text.nodes
sphinx.writers.text.Element(           sphinx.writers.text.SphinxTranslator(  sphinx.writers.text.addnodes           sphinx.writers.text.os
sphinx.writers.text.Generator(         sphinx.writers.text.TYPE_CHECKING      sphinx.writers.text.admonitionlabels   sphinx.writers.text.re
sphinx.writers.text.Iterable(          sphinx.writers.text.Table(             sphinx.writers.text.cast(              sphinx.writers.text.textwrap
sphinx.writers.text.List(              sphinx.writers.text.Text(              sphinx.writers.text.chain(             sphinx.writers.text.writers
sphinx.writers.text.MAXWIDTH           sphinx.writers.text.TextTranslator(    sphinx.writers.text.column_width(
sphinx.writers.text.Node(              sphinx.writers.text.TextWrapper(       sphinx.writers.text.groupby(
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=sphinx.writers.text.TextWriter)
<string>:19: (ERROR/3) Unknown interpreted text role "doc".
<string>:34: (ERROR/3) Unknown interpreted text role "file".
<string>:41: (ERROR/3) Unknown interpreted text role "doc".
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 416, in publish_string
    enable_exit_status=enable_exit_status)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 664, in publish_programmatically
    output = pub.publish(enable_exit_status=enable_exit_status)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 218, in publish
    self.apply_transforms()
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 198, in apply_transforms
    self.destination))
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/transforms/__init__.py", line 147, in populate_from_components
    self.add_transforms(component.get_transforms())
TypeError: get_transforms() missing 1 required positional argument: 'self'
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=sphinx.writers.text.TextWriter())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __init__() missing 1 required positional argument: 'builder'
>>> sphinx.writers.text.writers
<module 'docutils.writers' from '/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/writers/__init__.py'>
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=sphinx.writers.text.TextWriter(sphinx.builders.text.TextBuilder()))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'sphinx' has no attribute 'builders'
>>> import sphinx.writers.text
>>> import sphinx.builders.text
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=sphinx.writers.text.TextWriter(sphinx.builders.text.TextBuilder()))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __init__() missing 1 required positional argument: 'app'
>>> Path("hack")
PosixPath('hack')
>>> x = exec(Path("hack").read_text())
>>> x.
x.__bool__(           x.__dir__(            x.__format__(         x.__gt__(             x.__init_subclass__(  x.__ne__(             x.__reduce_ex__(      x.__sizeof__(
x.__class__(          x.__doc__             x.__ge__(             x.__hash__(           x.__le__(             x.__new__(            x.__repr__(           x.__str__(
x.__delattr__(        x.__eq__(             x.__getattribute__(   x.__init__(           x.__lt__(             x.__reduce__(         x.__setattr__(        x.__subclasshook__(
>>> TextWriter()
<__main__.TextWriter object at 0x7fe40149ad68>
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=TextWriter())
<string>:19: (ERROR/3) Unknown interpreted text role "doc".
<string>:34: (ERROR/3) Unknown interpreted text role "file".
<string>:41: (ERROR/3) Unknown interpreted text role "doc".
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 416, in publish_string
    enable_exit_status=enable_exit_status)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 664, in publish_programmatically
    output = pub.publish(enable_exit_status=enable_exit_status)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/core.py", line 219, in publish
    output = self.writer.write(self.document, self.destination)
  File "/home/tom/nextstrain/cli/.venv/lib/python3.6/site-packages/docutils/writers/__init__.py", line 78, in write
    self.translate()
  File "<string>", line 432, in translate
  File "<string>", line 441, in __init__
AttributeError: 'TextTranslator' object has no attribute 'config'
>>> x = exec(Path("hack").read_text())
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=TextWriter())
<string>:19: (ERROR/3) Unknown interpreted text role "doc".
<string>:34: (ERROR/3) Unknown interpreted text role "file".
<string>:41: (ERROR/3) Unknown interpreted text role "doc".
>>> m
b'Upload, download, and manage remote datasets and narratives.\n\nnextstrain.org is the primary remote source/destination, but Amazon S3\nbuckets are also supported and necessary for some use cases. [1]\n\nnextstrain.org\n   Remote paths are the same URLs used to view a dataset or narrative\n   on the web, e.g. "https://nextstrain.org/ncov/open/global".\n\n   As a convenience, the scheme ("https://") may be omitted, e.g.\n   "nextstrain.org/ncov/open/global".\n\n   As a further convenience for Nextstrain Groups URLs, the domain\n   ("nextstrain.org") may also be omitted, e.g. "groups/blab/sars-\n   like-cov" works as well as "https://nextstrain.org/groups/blab\n   /sars-like-cov".\n\n   Read-only actions may be performed against public paths without\n   authentication.  To manage a private Nextstrain Group or\n   upload/delete a public path, first login with nextstrain.org\n   credentials using >>:doc:`/commands/login`<<.\n\n   <SYSTEM MESSAGE: <string>:19: (ERROR/3) Unknown interpreted text\n   role "doc".>\n\nAmazon S3\n   Remote paths start with "s3://" and specify the bucket name and\n   individual file path/prefix, e.g. "s3://my-bucket/some/prefix".\n\n   All actions require AWS credentials.  The following environment\n   variables can be used to provide credentials:\n\n      * "AWS_ACCESS_KEY_ID"\n\n      * "AWS_SECRET_ACCESS_KEY"\n\n   Amazon\'s documentation includes more information on these env vars\n   as well as using a persistent credentials file\n   (>>:file:`~/.aws/credentials`<<).\n\n   <SYSTEM MESSAGE: <string>:34: (ERROR/3) Unknown interpreted text\n   role "file".>\n\nFor more information on dataset (Auspice JSON) and narrative\n(Markdown) files, see >>:doc:`docs.nextstrain.org:reference/data-\nformats`<<.\n\n<SYSTEM MESSAGE: <string>:41: (ERROR/3) Unknown interpreted text role\n"doc".>\n\n[1] In previous versions, only Amazon S3 buckets were supported.  The\n    introduction of nextstrain.org support largely obsoletes the need\n    to use S3 directly.  Exceptions include if you need to manage v1\n    datasets (i.e.  separate "*_tree.json" and "*_meta.json" files) or\n    Nextstrain Group overview/logo files ("group-overview.md" or\n    "group-logo.png").\n'
>>> Path("/tmp/man").write_bytes(m)
2155
>>> m = docutils.core.publish_string(nextstrain.cli.command.remote.__doc__, writer=TextWriter(), settings_overrides={"report_level":4})
>>> Path("/tmp/man").write_bytes(m)
1905
>>>
```

```
# sphinx.util.docutils
from docutils import nodes
from docutils.nodes import Node

class SphinxTranslator(nodes.NodeVisitor):
    """A base class for Sphinx translators.

    This class adds a support for visitor/departure method for super node class
    if visitor/departure method for node class is not found.

    It also provides helper methods for Sphinx translators.

    .. note:: The subclasses of this class might not work with docutils.
              This class is strongly coupled with Sphinx.
    """

    def __init__(self, document: nodes.document) -> None:
        super().__init__(document)
        self.settings = document.settings

    def dispatch_visit(self, node: Node) -> None:
        """
        Dispatch node to appropriate visitor method.
        The priority of visitor method is:

        1. ``self.visit_{node_class}()``
        2. ``self.visit_{super_node_class}()``
        3. ``self.unknown_visit()``
        """
        for node_class in node.__class__.__mro__:
            method = getattr(self, 'visit_%s' % (node_class.__name__), None)
            if method:
                method(node)
                break
        else:
            super().dispatch_visit(node)

    def dispatch_departure(self, node: Node) -> None:
        """
        Dispatch node to appropriate departure method.
        The priority of departure method is:

        1. ``self.depart_{node_class}()``
        2. ``self.depart_{super_node_class}()``
        3. ``self.unknown_departure()``
        """
        for node_class in node.__class__.__mro__:
            method = getattr(self, 'depart_%s' % (node_class.__name__), None)
            if method:
                method(node)
                break
        else:
            super().dispatch_departure(node)


# sphinx.writers.text
"""
    sphinx.writers.text
    ~~~~~~~~~~~~~~~~~~~

    Custom docutils writer for plain text.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""
import math
import os
import re
import textwrap
from itertools import chain, groupby
from typing import (TYPE_CHECKING, Any, Dict, Generator, Iterable, List, Optional, Set, Tuple,
                    Union, cast)

from docutils import nodes, writers
from docutils.nodes import Element, Node, Text
from docutils.utils import column_width

#from sphinx import addnodes
#from sphinx.locale import _, admonitionlabels
#from sphinx.util.docutils import SphinxTranslator

def _(x):
    return x


class Cell:
    """Represents a cell in a table.
    It can span multiple columns or multiple lines.
    """
    def __init__(self, text: str = "", rowspan: int = 1, colspan: int = 1) -> None:
        self.text = text
        self.wrapped: List[str] = []
        self.rowspan = rowspan
        self.colspan = colspan
        self.col: Optional[int] = None
        self.row: Optional[int] = None

    def __repr__(self) -> str:
        return "<Cell {!r} {}v{}/{}>{}>".format(
            self.text, self.row, self.rowspan, self.col, self.colspan
        )

    def __hash__(self) -> int:
        return hash((self.col, self.row))

    def wrap(self, width: int) -> None:
        self.wrapped = my_wrap(self.text, width)


class Table:
    """Represents a table, handling cells that can span multiple lines
    or rows, like::

       +-----------+-----+
       | AAA       | BBB |
       +-----+-----+     |
       |     | XXX |     |
       |     +-----+-----+
       | DDD | CCC       |
       +-----+-----------+

    This class can be used in two ways, either:

    - With absolute positions: call ``table[line, col] = Cell(...)``,
      this overwrites any existing cell(s) at these positions.

    - With relative positions: call the ``add_row()`` and
      ``add_cell(Cell(...))`` as needed.

    Cells spanning multiple rows or multiple columns (having a
    colspan or rowspan greater than one) are automatically referenced
    by all the table cells they cover. This is a useful
    representation as we can simply check
    ``if self[x, y] is self[x, y+1]`` to recognize a rowspan.

    Colwidth is not automatically computed, it has to be given, either
    at construction time, or during the table construction.

    Example usage::

       table = Table([6, 6])
       table.add_cell(Cell("foo"))
       table.add_cell(Cell("bar"))
       table.set_separator()
       table.add_row()
       table.add_cell(Cell("FOO"))
       table.add_cell(Cell("BAR"))
       print(table)
       +--------+--------+
       | foo    | bar    |
       |========|========|
       | FOO    | BAR    |
       +--------+--------+

    """
    def __init__(self, colwidth: List[int] = None) -> None:
        self.lines: List[List[Cell]] = []
        self.separator = 0
        self.colwidth: List[int] = (colwidth if colwidth is not None else [])
        self.current_line = 0
        self.current_col = 0

    def add_row(self) -> None:
        """Add a row to the table, to use with ``add_cell()``.  It is not needed
        to call ``add_row()`` before the first ``add_cell()``.
        """
        self.current_line += 1
        self.current_col = 0

    def set_separator(self) -> None:
        """Sets the separator below the current line."""
        self.separator = len(self.lines)

    def add_cell(self, cell: Cell) -> None:
        """Add a cell to the current line, to use with ``add_row()``.  To add
        a cell spanning multiple lines or rows, simply set the
        ``cell.colspan`` or ``cell.rowspan`` BEFORE inserting it into
        the table.
        """
        while self[self.current_line, self.current_col]:
            self.current_col += 1
        self[self.current_line, self.current_col] = cell
        self.current_col += cell.colspan

    def __getitem__(self, pos: Tuple[int, int]) -> Cell:
        line, col = pos
        self._ensure_has_line(line + 1)
        self._ensure_has_column(col + 1)
        return self.lines[line][col]

    def __setitem__(self, pos: Tuple[int, int], cell: Cell) -> None:
        line, col = pos
        self._ensure_has_line(line + cell.rowspan)
        self._ensure_has_column(col + cell.colspan)
        for dline in range(cell.rowspan):
            for dcol in range(cell.colspan):
                self.lines[line + dline][col + dcol] = cell
                cell.row = line
                cell.col = col

    def _ensure_has_line(self, line: int) -> None:
        while len(self.lines) < line:
            self.lines.append([])

    def _ensure_has_column(self, col: int) -> None:
        for line in self.lines:
            while len(line) < col:
                line.append(None)

    def __repr__(self) -> str:
        return "\n".join(repr(line) for line in self.lines)

    def cell_width(self, cell: Cell, source: List[int]) -> int:
        """Give the cell width, according to the given source (either
        ``self.colwidth`` or ``self.measured_widths``).
        This takes into account cells spanning multiple columns.
        """
        width = 0
        for i in range(self[cell.row, cell.col].colspan):
            width += source[cell.col + i]
        return width + (cell.colspan - 1) * 3

    @property
    def cells(self) -> Generator[Cell, None, None]:
        seen: Set[Cell] = set()
        for lineno, line in enumerate(self.lines):
            for colno, cell in enumerate(line):
                if cell and cell not in seen:
                    yield cell
                    seen.add(cell)

    def rewrap(self) -> None:
        """Call ``cell.wrap()`` on all cells, and measure each column width
        after wrapping (result written in ``self.measured_widths``).
        """
        self.measured_widths = self.colwidth[:]
        for cell in self.cells:
            cell.wrap(width=self.cell_width(cell, self.colwidth))
            if not cell.wrapped:
                continue
            width = math.ceil(max(column_width(x) for x in cell.wrapped) / cell.colspan)
            for col in range(cell.col, cell.col + cell.colspan):
                self.measured_widths[col] = max(self.measured_widths[col], width)

    def physical_lines_for_line(self, line: List[Cell]) -> int:
        """For a given line, compute the number of physical lines it spans
        due to text wrapping.
        """
        physical_lines = 1
        for cell in line:
            physical_lines = max(physical_lines, len(cell.wrapped))
        return physical_lines

    def __str__(self) -> str:
        out = []
        self.rewrap()

        def writesep(char: str = "-", lineno: Optional[int] = None) -> str:
            """Called on the line *before* lineno.
            Called with no *lineno* for the last sep.
            """
            out: List[str] = []
            for colno, width in enumerate(self.measured_widths):
                if (
                    lineno is not None and
                    lineno > 0 and
                    self[lineno, colno] is self[lineno - 1, colno]
                ):
                    out.append(" " * (width + 2))
                else:
                    out.append(char * (width + 2))
            head = "+" if out[0][0] == "-" else "|"
            tail = "+" if out[-1][0] == "-" else "|"
            glue = [
                "+" if left[0] == "-" or right[0] == "-" else "|"
                for left, right in zip(out, out[1:])
            ]
            glue.append(tail)
            return head + "".join(chain.from_iterable(zip(out, glue)))

        for lineno, line in enumerate(self.lines):
            if self.separator and lineno == self.separator:
                out.append(writesep("=", lineno))
            else:
                out.append(writesep("-", lineno))
            for physical_line in range(self.physical_lines_for_line(line)):
                linestr = ["|"]
                for colno, cell in enumerate(line):
                    if cell.col != colno:
                        continue
                    if lineno != cell.row:
                        physical_text = ""
                    elif physical_line >= len(cell.wrapped):
                        physical_text = ""
                    else:
                        physical_text = cell.wrapped[physical_line]
                    adjust_len = len(physical_text) - column_width(physical_text)
                    linestr.append(
                        " " +
                        physical_text.ljust(
                            self.cell_width(cell, self.measured_widths) + 1 + adjust_len
                        ) + "|"
                    )
                out.append("".join(linestr))
        out.append(writesep("-"))
        return "\n".join(out)


class TextWrapper(textwrap.TextWrapper):
    """Custom subclass that uses a different word separator regex."""

    wordsep_re = re.compile(
        r'(\s+|'                                  # any whitespace
        r'(?<=\s)(?::[a-z-]+:)?`\S+|'             # interpreted text start
        r'[^\s\w]*\w+[a-zA-Z]-(?=\w+[a-zA-Z])|'   # hyphenated words
        r'(?<=[\w\!\"\'\&\.\,\?])-{2,}(?=\w))')   # em-dash

    def _wrap_chunks(self, chunks: List[str]) -> List[str]:
        """_wrap_chunks(chunks : [string]) -> [string]

        The original _wrap_chunks uses len() to calculate width.
        This method respects wide/fullwidth characters for width adjustment.
        """
        lines: List[str] = []
        if self.width <= 0:
            raise ValueError("invalid width %r (must be > 0)" % self.width)

        chunks.reverse()

        while chunks:
            cur_line = []
            cur_len = 0

            if lines:
                indent = self.subsequent_indent
            else:
                indent = self.initial_indent

            width = self.width - column_width(indent)

            if self.drop_whitespace and chunks[-1].strip() == '' and lines:
                del chunks[-1]

            while chunks:
                l = column_width(chunks[-1])

                if cur_len + l <= width:
                    cur_line.append(chunks.pop())
                    cur_len += l

                else:
                    break

            if chunks and column_width(chunks[-1]) > width:
                self._handle_long_word(chunks, cur_line, cur_len, width)

            if self.drop_whitespace and cur_line and cur_line[-1].strip() == '':
                del cur_line[-1]

            if cur_line:
                lines.append(indent + ''.join(cur_line))

        return lines

    def _break_word(self, word: str, space_left: int) -> Tuple[str, str]:
        """_break_word(word : string, space_left : int) -> (string, string)

        Break line by unicode width instead of len(word).
        """
        total = 0
        for i, c in enumerate(word):
            total += column_width(c)
            if total > space_left:
                return word[:i - 1], word[i - 1:]
        return word, ''

    def _split(self, text: str) -> List[str]:
        """_split(text : string) -> [string]

        Override original method that only split by 'wordsep_re'.
        This '_split' splits wide-characters into chunks by one character.
        """
        def split(t: str) -> List[str]:
            return super(TextWrapper, self)._split(t)
        chunks: List[str] = []
        for chunk in split(text):
            for w, g in groupby(chunk, column_width):
                if w == 1:
                    chunks.extend(split(''.join(g)))
                else:
                    chunks.extend(list(g))
        return chunks

    def _handle_long_word(self, reversed_chunks: List[str], cur_line: List[str],
                          cur_len: int, width: int) -> None:
        """_handle_long_word(chunks : [string],
                             cur_line : [string],
                             cur_len : int, width : int)

        Override original method for using self._break_word() instead of slice.
        """
        space_left = max(width - cur_len, 1)
        if self.break_long_words:
            l, r = self._break_word(reversed_chunks[-1], space_left)
            cur_line.append(l)
            reversed_chunks[-1] = r

        elif not cur_line:
            cur_line.append(reversed_chunks.pop())


MAXWIDTH = 70
STDINDENT = 3


def my_wrap(text: str, width: int = MAXWIDTH, **kwargs: Any) -> List[str]:
    w = TextWrapper(width=width, **kwargs)
    return w.wrap(text)


class TextWriter(writers.Writer):
    supported = ('text',)
    settings_spec = ('No options here.', '', ())
    settings_defaults: Dict = {}

    output: str = None

    def __init__(self) -> None:
        super().__init__()

    def translate(self) -> None:
        visitor = TextTranslator(self.document)
        self.document.walkabout(visitor)
        self.output = cast(TextTranslator, visitor).body


class TextTranslator(SphinxTranslator):
    def __init__(self, document: nodes.document) -> None:
        super().__init__(document)

        newlines = None #self.config.text_newlines
        if newlines == 'windows':
            self.nl = '\r\n'
        elif newlines == 'native':
            self.nl = os.linesep
        else:
            self.nl = '\n'
        self.sectionchars = None #self.config.text_sectionchars
        self.add_secnumbers = None #self.config.text_add_secnumbers
        self.secnumber_suffix = None #self.config.text_secnumber_suffix
        self.states: List[List[Tuple[int, Union[str, List[str]]]]] = [[]]
        self.stateindent = [0]
        self.list_counter: List[int] = []
        self.sectionlevel = 0
        self.lineblocklevel = 0
        self.table: Table = None

    def add_text(self, text: str) -> None:
        self.states[-1].append((-1, text))

    def new_state(self, indent: int = STDINDENT) -> None:
        self.states.append([])
        self.stateindent.append(indent)

    def end_state(self, wrap: bool = True, end: List[str] = [''], first: str = None) -> None:
        content = self.states.pop()
        maxindent = sum(self.stateindent)
        indent = self.stateindent.pop()
        result: List[Tuple[int, List[str]]] = []
        toformat: List[str] = []

        def do_format() -> None:
            if not toformat:
                return
            if wrap:
                res = my_wrap(''.join(toformat), width=MAXWIDTH - maxindent)
            else:
                res = ''.join(toformat).splitlines()
            if end:
                res += end
            result.append((indent, res))
        for itemindent, item in content:
            if itemindent == -1:
                toformat.append(item)  # type: ignore
            else:
                do_format()
                result.append((indent + itemindent, item))  # type: ignore
                toformat = []
        do_format()
        if first is not None and result:
            # insert prefix into first line (ex. *, [1], See also, etc.)
            newindent = result[0][0] - indent
            if result[0][1] == ['']:
                result.insert(0, (newindent, [first]))
            else:
                text = first + result[0][1].pop(0)
                result.insert(0, (newindent, [text]))

        self.states[-1].extend(result)

    def visit_document(self, node: Element) -> None:
        self.new_state(0)

    def depart_document(self, node: Element) -> None:
        self.end_state()
        self.body = self.nl.join(line and (' ' * indent + line)
                                 for indent, lines in self.states[0]
                                 for line in lines)
        # XXX header/footer?

    def visit_section(self, node: Element) -> None:
        self._title_char = self.sectionchars[self.sectionlevel]
        self.sectionlevel += 1

    def depart_section(self, node: Element) -> None:
        self.sectionlevel -= 1

    def visit_topic(self, node: Element) -> None:
        self.new_state(0)

    def depart_topic(self, node: Element) -> None:
        self.end_state()

    visit_sidebar = visit_topic
    depart_sidebar = depart_topic

    def visit_rubric(self, node: Element) -> None:
        self.new_state(0)
        self.add_text('-[ ')

    def depart_rubric(self, node: Element) -> None:
        self.add_text(' ]-')
        self.end_state()

    def visit_compound(self, node: Element) -> None:
        pass

    def depart_compound(self, node: Element) -> None:
        pass

    def visit_glossary(self, node: Element) -> None:
        pass

    def depart_glossary(self, node: Element) -> None:
        pass

    def visit_title(self, node: Element) -> None:
        if isinstance(node.parent, nodes.Admonition):
            self.add_text(node.astext() + ': ')
            raise nodes.SkipNode
        self.new_state(0)

    def get_section_number_string(self, node: Element) -> str:
        return ''

    def depart_title(self, node: Element) -> None:
        if isinstance(node.parent, nodes.section):
            char = self._title_char
        else:
            char = '^'
        text = ''
        text = ''.join(x[1] for x in self.states.pop() if x[0] == -1)  # type: ignore
        if self.add_secnumbers:
            text = self.get_section_number_string(node) + text
        self.stateindent.pop()
        title = ['', text, '%s' % (char * column_width(text)), '']
        if len(self.states) == 2 and len(self.states[-1]) == 0:
            # remove an empty line before title if it is first section title in the document
            title.pop(0)
        self.states[-1].append((0, title))

    def visit_subtitle(self, node: Element) -> None:
        pass

    def depart_subtitle(self, node: Element) -> None:
        pass

    def visit_attribution(self, node: Element) -> None:
        self.add_text('-- ')

    def depart_attribution(self, node: Element) -> None:
        pass

    #############################################################
    # Domain-specific object descriptions
    #############################################################

    # Top-level nodes
    #################

    def visit_desc(self, node: Element) -> None:
        pass

    def depart_desc(self, node: Element) -> None:
        pass

    def visit_desc_signature(self, node: Element) -> None:
        self.new_state(0)

    def depart_desc_signature(self, node: Element) -> None:
        # XXX: wrap signatures in a way that makes sense
        self.end_state(wrap=False, end=None)

    def visit_desc_signature_line(self, node: Element) -> None:
        pass

    def depart_desc_signature_line(self, node: Element) -> None:
        self.add_text('\n')

    def visit_desc_content(self, node: Element) -> None:
        self.new_state()
        self.add_text(self.nl)

    def depart_desc_content(self, node: Element) -> None:
        self.end_state()

    def visit_desc_inline(self, node: Element) -> None:
        pass

    def depart_desc_inline(self, node: Element) -> None:
        pass

    # Nodes for high-level structure in signatures
    ##############################################

    def visit_desc_name(self, node: Element) -> None:
        pass

    def depart_desc_name(self, node: Element) -> None:
        pass

    def visit_desc_addname(self, node: Element) -> None:
        pass

    def depart_desc_addname(self, node: Element) -> None:
        pass

    def visit_desc_type(self, node: Element) -> None:
        pass

    def depart_desc_type(self, node: Element) -> None:
        pass

    def visit_desc_returns(self, node: Element) -> None:
        self.add_text(' -> ')

    def depart_desc_returns(self, node: Element) -> None:
        pass

    def visit_desc_parameterlist(self, node: Element) -> None:
        self.add_text('(')
        self.first_param = 1

    def depart_desc_parameterlist(self, node: Element) -> None:
        self.add_text(')')

    def visit_desc_parameter(self, node: Element) -> None:
        if not self.first_param:
            self.add_text(', ')
        else:
            self.first_param = 0
        self.add_text(node.astext())
        raise nodes.SkipNode

    def visit_desc_optional(self, node: Element) -> None:
        self.add_text('[')

    def depart_desc_optional(self, node: Element) -> None:
        self.add_text(']')

    def visit_desc_annotation(self, node: Element) -> None:
        pass

    def depart_desc_annotation(self, node: Element) -> None:
        pass

    ##############################################

    def visit_figure(self, node: Element) -> None:
        self.new_state()

    def depart_figure(self, node: Element) -> None:
        self.end_state()

    def visit_caption(self, node: Element) -> None:
        pass

    def depart_caption(self, node: Element) -> None:
        pass

    def visit_productionlist(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_footnote(self, node: Element) -> None:
        label = cast(nodes.label, node[0])
        self._footnote = label.astext().strip()
        self.new_state(len(self._footnote) + 3)

    def depart_footnote(self, node: Element) -> None:
        self.end_state(first='[%s] ' % self._footnote)

    def visit_citation(self, node: Element) -> None:
        if len(node) and isinstance(node[0], nodes.label):
            self._citlabel = node[0].astext()
        else:
            self._citlabel = ''
        self.new_state(len(self._citlabel) + 3)

    def depart_citation(self, node: Element) -> None:
        self.end_state(first='[%s] ' % self._citlabel)

    def visit_label(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_legend(self, node: Element) -> None:
        pass

    def depart_legend(self, node: Element) -> None:
        pass

    # XXX: option list could use some better styling

    def visit_option_list(self, node: Element) -> None:
        pass

    def depart_option_list(self, node: Element) -> None:
        pass

    def visit_option_list_item(self, node: Element) -> None:
        self.new_state(0)

    def depart_option_list_item(self, node: Element) -> None:
        self.end_state()

    def visit_option_group(self, node: Element) -> None:
        self._firstoption = True

    def depart_option_group(self, node: Element) -> None:
        self.add_text('     ')

    def visit_option(self, node: Element) -> None:
        if self._firstoption:
            self._firstoption = False
        else:
            self.add_text(', ')

    def depart_option(self, node: Element) -> None:
        pass

    def visit_option_string(self, node: Element) -> None:
        pass

    def depart_option_string(self, node: Element) -> None:
        pass

    def visit_option_argument(self, node: Element) -> None:
        self.add_text(node['delimiter'])

    def depart_option_argument(self, node: Element) -> None:
        pass

    def visit_description(self, node: Element) -> None:
        pass

    def depart_description(self, node: Element) -> None:
        pass

    def visit_tabular_col_spec(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_colspec(self, node: Element) -> None:
        self.table.colwidth.append(node["colwidth"])
        raise nodes.SkipNode

    def visit_tgroup(self, node: Element) -> None:
        pass

    def depart_tgroup(self, node: Element) -> None:
        pass

    def visit_thead(self, node: Element) -> None:
        pass

    def depart_thead(self, node: Element) -> None:
        pass

    def visit_tbody(self, node: Element) -> None:
        self.table.set_separator()

    def depart_tbody(self, node: Element) -> None:
        pass

    def visit_row(self, node: Element) -> None:
        if self.table.lines:
            self.table.add_row()

    def depart_row(self, node: Element) -> None:
        pass

    def visit_entry(self, node: Element) -> None:
        self.entry = Cell(
            rowspan=node.get("morerows", 0) + 1, colspan=node.get("morecols", 0) + 1
        )
        self.new_state(0)

    def depart_entry(self, node: Element) -> None:
        text = self.nl.join(self.nl.join(x[1]) for x in self.states.pop())
        self.stateindent.pop()
        self.entry.text = text
        self.table.add_cell(self.entry)
        self.entry = None

    def visit_table(self, node: Element) -> None:
        if self.table:
            raise NotImplementedError('Nested tables are not supported.')
        self.new_state(0)
        self.table = Table()

    def depart_table(self, node: Element) -> None:
        self.add_text(str(self.table))
        self.table = None
        self.end_state(wrap=False)

    def visit_acks(self, node: Element) -> None:
        bullet_list = cast(nodes.bullet_list, node[0])
        list_items = cast(Iterable[nodes.list_item], bullet_list)
        self.new_state(0)
        self.add_text(', '.join(n.astext() for n in list_items) + '.')
        self.end_state()
        raise nodes.SkipNode

    def visit_image(self, node: Element) -> None:
        if 'alt' in node.attributes:
            self.add_text(_('[image: %s]') % node['alt'])
        self.add_text(_('[image]'))
        raise nodes.SkipNode

    def visit_transition(self, node: Element) -> None:
        indent = sum(self.stateindent)
        self.new_state(0)
        self.add_text('=' * (MAXWIDTH - indent))
        self.end_state()
        raise nodes.SkipNode

    def visit_bullet_list(self, node: Element) -> None:
        self.list_counter.append(-1)

    def depart_bullet_list(self, node: Element) -> None:
        self.list_counter.pop()

    def visit_enumerated_list(self, node: Element) -> None:
        self.list_counter.append(node.get('start', 1) - 1)

    def depart_enumerated_list(self, node: Element) -> None:
        self.list_counter.pop()

    def visit_definition_list(self, node: Element) -> None:
        self.list_counter.append(-2)

    def depart_definition_list(self, node: Element) -> None:
        self.list_counter.pop()

    def visit_list_item(self, node: Element) -> None:
        if self.list_counter[-1] == -1:
            # bullet list
            self.new_state(2)
        elif self.list_counter[-1] == -2:
            # definition list
            pass
        else:
            # enumerated list
            self.list_counter[-1] += 1
            self.new_state(len(str(self.list_counter[-1])) + 2)

    def depart_list_item(self, node: Element) -> None:
        if self.list_counter[-1] == -1:
            self.end_state(first='* ')
        elif self.list_counter[-1] == -2:
            pass
        else:
            self.end_state(first='%s. ' % self.list_counter[-1])

    def visit_definition_list_item(self, node: Element) -> None:
        self._classifier_count_in_li = len(list(node.traverse(nodes.classifier)))

    def depart_definition_list_item(self, node: Element) -> None:
        pass

    def visit_term(self, node: Element) -> None:
        self.new_state(0)

    def depart_term(self, node: Element) -> None:
        if not self._classifier_count_in_li:
            self.end_state(end=None)

    def visit_classifier(self, node: Element) -> None:
        self.add_text(' : ')

    def depart_classifier(self, node: Element) -> None:
        self._classifier_count_in_li -= 1
        if not self._classifier_count_in_li:
            self.end_state(end=None)

    def visit_definition(self, node: Element) -> None:
        self.new_state()

    def depart_definition(self, node: Element) -> None:
        self.end_state()

    def visit_field_list(self, node: Element) -> None:
        pass

    def depart_field_list(self, node: Element) -> None:
        pass

    def visit_field(self, node: Element) -> None:
        pass

    def depart_field(self, node: Element) -> None:
        pass

    def visit_field_name(self, node: Element) -> None:
        self.new_state(0)

    def depart_field_name(self, node: Element) -> None:
        self.add_text(':')
        self.end_state(end=None)

    def visit_field_body(self, node: Element) -> None:
        self.new_state()

    def depart_field_body(self, node: Element) -> None:
        self.end_state()

    def visit_centered(self, node: Element) -> None:
        pass

    def depart_centered(self, node: Element) -> None:
        pass

    def visit_hlist(self, node: Element) -> None:
        pass

    def depart_hlist(self, node: Element) -> None:
        pass

    def visit_hlistcol(self, node: Element) -> None:
        pass

    def depart_hlistcol(self, node: Element) -> None:
        pass

    def visit_admonition(self, node: Element) -> None:
        self.new_state(0)

    def depart_admonition(self, node: Element) -> None:
        self.end_state()

    def _visit_admonition(self, node: Element) -> None:
        self.new_state(2)

    def _depart_admonition(self, node: Element) -> None:
        admonitionlabels = {
            'attention': _('Attention'),
            'caution':   _('Caution'),
            'danger':    _('Danger'),
            'error':     _('Error'),
            'hint':      _('Hint'),
            'important': _('Important'),
            'note':      _('Note'),
            'seealso':   _('See also'),
            'tip':       _('Tip'),
            'warning':   _('Warning'),
        }
        label = admonitionlabels[node.tagname]
        indent = sum(self.stateindent) + len(label)
        if (len(self.states[-1]) == 1 and
                self.states[-1][0][0] == 0 and
                MAXWIDTH - indent >= sum(len(s) for s in self.states[-1][0][1])):
            # short text: append text after admonition label
            self.stateindent[-1] += len(label)
            self.end_state(first=label + ': ')
        else:
            # long text: append label before the block
            self.states[-1].insert(0, (0, [self.nl]))
            self.end_state(first=label + ':')

    visit_attention = _visit_admonition
    depart_attention = _depart_admonition
    visit_caution = _visit_admonition
    depart_caution = _depart_admonition
    visit_danger = _visit_admonition
    depart_danger = _depart_admonition
    visit_error = _visit_admonition
    depart_error = _depart_admonition
    visit_hint = _visit_admonition
    depart_hint = _depart_admonition
    visit_important = _visit_admonition
    depart_important = _depart_admonition
    visit_note = _visit_admonition
    depart_note = _depart_admonition
    visit_tip = _visit_admonition
    depart_tip = _depart_admonition
    visit_warning = _visit_admonition
    depart_warning = _depart_admonition
    visit_seealso = _visit_admonition
    depart_seealso = _depart_admonition

    def visit_versionmodified(self, node: Element) -> None:
        self.new_state(0)

    def depart_versionmodified(self, node: Element) -> None:
        self.end_state()

    def visit_literal_block(self, node: Element) -> None:
        self.new_state()

    def depart_literal_block(self, node: Element) -> None:
        self.end_state(wrap=False)

    def visit_doctest_block(self, node: Element) -> None:
        self.new_state(0)

    def depart_doctest_block(self, node: Element) -> None:
        self.end_state(wrap=False)

    def visit_line_block(self, node: Element) -> None:
        self.new_state()
        self.lineblocklevel += 1

    def depart_line_block(self, node: Element) -> None:
        self.lineblocklevel -= 1
        self.end_state(wrap=False, end=None)
        if not self.lineblocklevel:
            self.add_text('\n')

    def visit_line(self, node: Element) -> None:
        pass

    def depart_line(self, node: Element) -> None:
        self.add_text('\n')

    def visit_block_quote(self, node: Element) -> None:
        self.new_state()

    def depart_block_quote(self, node: Element) -> None:
        self.end_state()

    def visit_compact_paragraph(self, node: Element) -> None:
        pass

    def depart_compact_paragraph(self, node: Element) -> None:
        pass

    def visit_paragraph(self, node: Element) -> None:
        if not isinstance(node.parent, nodes.Admonition):
            self.new_state(0)

    def depart_paragraph(self, node: Element) -> None:
        if not isinstance(node.parent, nodes.Admonition):
            self.end_state()

    def visit_target(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_index(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_toctree(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_substitution_definition(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_pending_xref(self, node: Element) -> None:
        pass

    def depart_pending_xref(self, node: Element) -> None:
        pass

    def visit_reference(self, node: Element) -> None:
        if self.add_secnumbers:
            numbers = node.get("secnumber")
            if numbers is not None:
                self.add_text('.'.join(map(str, numbers)) + self.secnumber_suffix)

    def depart_reference(self, node: Element) -> None:
        pass

    def visit_number_reference(self, node: Element) -> None:
        text = nodes.Text(node.get('title', '#'))
        self.visit_Text(text)
        raise nodes.SkipNode

    def visit_download_reference(self, node: Element) -> None:
        pass

    def depart_download_reference(self, node: Element) -> None:
        pass

    def visit_emphasis(self, node: Element) -> None:
        self.add_text('*')

    def depart_emphasis(self, node: Element) -> None:
        self.add_text('*')

    def visit_literal_emphasis(self, node: Element) -> None:
        self.add_text('*')

    def depart_literal_emphasis(self, node: Element) -> None:
        self.add_text('*')

    def visit_strong(self, node: Element) -> None:
        self.add_text('**')

    def depart_strong(self, node: Element) -> None:
        self.add_text('**')

    def visit_literal_strong(self, node: Element) -> None:
        self.add_text('**')

    def depart_literal_strong(self, node: Element) -> None:
        self.add_text('**')

    def visit_abbreviation(self, node: Element) -> None:
        self.add_text('')

    def depart_abbreviation(self, node: Element) -> None:
        if node.hasattr('explanation'):
            self.add_text(' (%s)' % node['explanation'])

    def visit_manpage(self, node: Element) -> None:
        return self.visit_literal_emphasis(node)

    def depart_manpage(self, node: Element) -> None:
        return self.depart_literal_emphasis(node)

    def visit_title_reference(self, node: Element) -> None:
        self.add_text('*')

    def depart_title_reference(self, node: Element) -> None:
        self.add_text('*')

    def visit_literal(self, node: Element) -> None:
        self.add_text('"')

    def depart_literal(self, node: Element) -> None:
        self.add_text('"')

    def visit_subscript(self, node: Element) -> None:
        self.add_text('_')

    def depart_subscript(self, node: Element) -> None:
        pass

    def visit_superscript(self, node: Element) -> None:
        self.add_text('^')

    def depart_superscript(self, node: Element) -> None:
        pass

    def visit_footnote_reference(self, node: Element) -> None:
        self.add_text('[%s]' % node.astext())
        raise nodes.SkipNode

    def visit_citation_reference(self, node: Element) -> None:
        self.add_text('[%s]' % node.astext())
        raise nodes.SkipNode

    def visit_Text(self, node: Text) -> None:
        self.add_text(node.astext())

    def depart_Text(self, node: Text) -> None:
        pass

    def visit_generated(self, node: Element) -> None:
        pass

    def depart_generated(self, node: Element) -> None:
        pass

    def visit_inline(self, node: Element) -> None:
        if 'xref' in node['classes'] or 'term' in node['classes']:
            self.add_text('*')

    def depart_inline(self, node: Element) -> None:
        if 'xref' in node['classes'] or 'term' in node['classes']:
            self.add_text('*')

    def visit_container(self, node: Element) -> None:
        pass

    def depart_container(self, node: Element) -> None:
        pass

    def visit_problematic(self, node: Element) -> None:
        self.add_text('>>')

    def depart_problematic(self, node: Element) -> None:
        self.add_text('<<')

    def visit_system_message(self, node: Element) -> None:
        self.new_state(0)
        self.add_text('<SYSTEM MESSAGE: %s>' % node.astext())
        self.end_state()
        raise nodes.SkipNode

    def visit_comment(self, node: Element) -> None:
        raise nodes.SkipNode

    def visit_meta(self, node: Element) -> None:
        # only valid for HTML
        raise nodes.SkipNode

    def visit_raw(self, node: Element) -> None:
        if 'text' in node.get('format', '').split():
            self.new_state(0)
            self.add_text(node.astext())
            self.end_state(wrap = False)
        raise nodes.SkipNode

    def visit_math(self, node: Element) -> None:
        pass

    def depart_math(self, node: Element) -> None:
        pass

    def visit_math_block(self, node: Element) -> None:
        self.new_state()

    def depart_math_block(self, node: Element) -> None:
        self.end_state()

    def unknown_visit(self, node: Node) -> None:
        raise NotImplementedError('Unknown node: ' + node.__class__.__name__)
```
